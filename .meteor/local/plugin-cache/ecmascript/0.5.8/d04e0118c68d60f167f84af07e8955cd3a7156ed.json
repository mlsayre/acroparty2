{"metadata":{"usedHelpers":["classCallCheck"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/lbee:moment-helpers/client.js","filenameRelative":"/packages/lbee:moment-helpers/client.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/lbee:moment-helpers/client.js.map","sourceFileName":"/packages/lbee:moment-helpers/client.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"client"},"ignored":false,"code":"var _classCallCheck;module.import('babel-runtime/helpers/classCallCheck',{\"default\":function(v){_classCallCheck=v}});\n\nvar MomentHelper = function () {\n  function MomentHelper() {\n    _classCallCheck(this, MomentHelper);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    this.args = args;\n\n    // Calling this reactive property ensure the helper is updated\n    this.locale = mo.currentLocale.get();\n\n    // eg. {{moFormat date=myDate}} / {{moFormat myDate}} will do the same thing\n    this.keywords = args.pop();\n    this.dateA = args[0] || this.keywords.hash.d || this.keywords.hash.a;\n\n    // processes what was given to ensure we end up with a moment object\n    this.moDate = mo._getMoment(this.dateA);\n  }\n\n  MomentHelper.prototype.moFormat = function () {\n    function moFormat() {\n      if (this.moDate) {\n        this.formatToken = this.args[1] || this.keywords.hash.f;\n\n        return this.moDate.format(mo._getToken(this.formatToken, this.moDate));\n      }\n      // fail silently if the date is not worked out to be a moment\n      return null;\n    }\n\n    return moFormat;\n  }();\n\n  return MomentHelper;\n}();\n\nTemplate.registerHelper('moFormat', function () {\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return new (Function.prototype.bind.apply(MomentHelper, [null].concat(args)))().moFormat();\n});\n\nTemplate.registerHelper('moDiff', function () {\n  function moDiff() {\n    // Calling this reactive property ensure the helper is updated\n    var locale = mo.currentLocale.get(); // eslint-disable-line\n    var result = void 0;\n\n    // enables the arguments to be provided as args or vars\n\n    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    var kw = args.pop();\n    var dateA = mo._getMoment(args[0] || kw.hash.a);\n    var dateB = mo._getMoment(args[1] || kw.hash.b);\n    var units = args[2] || kw.hash.units || 'seconds';\n    var returnFloat = args[3] || kw.hash.returnFloat;\n\n    // if the returnFloat is truthy convert it to true, or falsy = false\n    if (returnFloat) {\n      returnFloat = true;\n    } else {\n      returnFloat = false;\n    }\n\n    // if the two dates are valid moment objects, send the result\n    if (dateA && dateB) {\n      result = dateA.diff(dateB, units, returnFloat);\n    }\n\n    // fail silently if the dates were not processed to a moment\n    return result;\n  }\n\n  return moDiff;\n}());\n\nTemplate.registerHelper('moFrom', function () {\n  function moFrom() {\n    // Calling this reactive property ensure the helper is updated\n    var locale = mo.currentLocale.get(); // eslint-disable-line\n    var result = void 0;\n\n    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    var kw = args.pop();\n    var dateA = mo._getMoment(args[0] || kw.hash.a);\n    var dateB = mo._getMoment(args[1] || kw.hash.b);\n    var withoutSuffix = args[2] || kw.hash.withoutSuffix;\n\n    // if the withoutSuffix is truthy convert it to true, or falsy = false\n    if (withoutSuffix) {\n      withoutSuffix = true;\n    } else {\n      withoutSuffix = false;\n    }\n\n    // if the two dates are valid moment objects, send the result\n    if (dateA && dateB) {\n      result = dateA.from(dateB, withoutSuffix);\n    }\n\n    // fail silently if the dates were not processed to a moment\n    return result;\n  }\n\n  return moFrom;\n}());\n\nTemplate.registerHelper('moFromNow', function () {\n  function moFromNow() {\n    // Calling this reactive property ensure the helper is updated\n    var locale = mo.currentLocale.get(); // eslint-disable-line\n\n    // enables the arguments to be provided as args or vars\n\n    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    var kw = args.pop();\n    var date = args[0] || kw.hash.d;\n    var withoutSuffix = args[1] || kw.hash.withoutSuffix;\n\n    // if the withoutSuffix is truthy convert it to true, or falsy = false\n    if (withoutSuffix) {\n      withoutSuffix = true;\n    } else {\n      withoutSuffix = false;\n    }\n\n    // work with what is given to get a moment object\n    var moDate = mo._getMoment(date);\n\n    // if we did end up with a valid object above, send the result\n    if (moDate) {\n      return moDate.fromNow(withoutSuffix);\n    }\n\n    // fail silently if the dates were not processed to a moment\n    return null;\n  }\n\n  return moFromNow;\n}());\n\nTemplate.registerHelper('moCalendar', function () {\n  function moCalendar() {\n    // Calling this reactive property ensure the helper is updated\n    var locale = mo.currentLocale.get(); // eslint-disable-line\n\n    // enables the arguments to be provided as args or vars\n    // eg. {{moFormat date=myDate}} or {{moFormat myDate}} will do the same thing\n\n    for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    var kw = args.pop();\n    var date = args[0] || kw.hash.d;\n    var referenceDate = args[1] || kw.hash.r;\n    var moReferenceDate = void 0;\n\n    // processes what was given to ensure we end up with a moment object\n    var moDate = mo._getMoment(date);\n\n    // never let reference date default to now if not provided\n    if (referenceDate) {\n      moReferenceDate = mo._getMoment(referenceDate);\n    }\n\n    // fail silently if the date is not worked out to be a moment\n    if (moDate) {\n      if (moReferenceDate) {\n        return moDate.calendar(moReferenceDate);\n      }\n      return moDate.calendar();\n    }\n\n    return null;\n  }\n\n  return moCalendar;\n}());\n\nTemplate.registerHelper('moNow', function () {\n  return mo.now.get();\n});","ast":null,"map":{"version":3,"sources":["/packages/lbee:moment-helpers/client.js"],"names":[],"mappings":"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","file":"/packages/lbee:moment-helpers/client.js.map","sourcesContent":["class MomentHelper {\n\n  constructor(...args) {\n    this.args = args;\n\n    // Calling this reactive property ensure the helper is updated\n    this.locale = mo.currentLocale.get();\n\n    // eg. {{moFormat date=myDate}} / {{moFormat myDate}} will do the same thing\n    this.keywords = args.pop();\n    this.dateA = args[0] || this.keywords.hash.d || this.keywords.hash.a;\n\n    // processes what was given to ensure we end up with a moment object\n    this.moDate = mo._getMoment(this.dateA);\n  }\n\n  moFormat() {\n    if (this.moDate) {\n      this.formatToken = this.args[1] || this.keywords.hash.f;\n\n      return this.moDate.format(\n        mo._getToken(this.formatToken, this.moDate)\n      );\n    }\n    // fail silently if the date is not worked out to be a moment\n    return null;\n  }\n\n}\n\nTemplate.registerHelper('moFormat', (...args) =>\n  new MomentHelper(...args).moFormat()\n);\n\nTemplate.registerHelper('moDiff', function moDiff(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n  let result;\n\n  // enables the arguments to be provided as args or vars\n  const kw = args.pop();\n  const dateA = mo._getMoment(args[0] || kw.hash.a);\n  const dateB = mo._getMoment(args[1] || kw.hash.b);\n  const units = args[2] || kw.hash.units || 'seconds';\n  let returnFloat = args[3] || kw.hash.returnFloat;\n\n  // if the returnFloat is truthy convert it to true, or falsy = false\n  if (returnFloat) {\n    returnFloat = true;\n  } else {\n    returnFloat = false;\n  }\n\n  // if the two dates are valid moment objects, send the result\n  if (dateA && dateB) {\n    result = dateA.diff(dateB, units, returnFloat);\n  }\n\n  // fail silently if the dates were not processed to a moment\n  return result;\n});\n\nTemplate.registerHelper('moFrom', function moFrom(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n  let result;\n\n  const kw = args.pop();\n  const dateA = mo._getMoment(args[0] || kw.hash.a);\n  const dateB = mo._getMoment(args[1] || kw.hash.b);\n  let withoutSuffix = args[2] || kw.hash.withoutSuffix;\n\n  // if the withoutSuffix is truthy convert it to true, or falsy = false\n  if (withoutSuffix) {\n    withoutSuffix = true;\n  } else {\n    withoutSuffix = false;\n  }\n\n  // if the two dates are valid moment objects, send the result\n  if (dateA && dateB) {\n    result = dateA.from(dateB, withoutSuffix);\n  }\n\n  // fail silently if the dates were not processed to a moment\n  return result;\n});\n\nTemplate.registerHelper('moFromNow', function moFromNow(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n\n  // enables the arguments to be provided as args or vars\n  const kw = args.pop();\n  const date = args[0] || kw.hash.d;\n  let withoutSuffix = args[1] || kw.hash.withoutSuffix;\n\n  // if the withoutSuffix is truthy convert it to true, or falsy = false\n  if (withoutSuffix) {\n    withoutSuffix = true;\n  } else {\n    withoutSuffix = false;\n  }\n\n  // work with what is given to get a moment object\n  const moDate = mo._getMoment(date);\n\n  // if we did end up with a valid object above, send the result\n  if (moDate) {\n    return moDate.fromNow(withoutSuffix);\n  }\n\n  // fail silently if the dates were not processed to a moment\n  return null;\n});\n\nTemplate.registerHelper('moCalendar', function moCalendar(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n\n  // enables the arguments to be provided as args or vars\n  // eg. {{moFormat date=myDate}} or {{moFormat myDate}} will do the same thing\n  const kw = args.pop();\n  const date = args[0] || kw.hash.d;\n  const referenceDate = args[1] || kw.hash.r;\n  let moReferenceDate;\n\n  // processes what was given to ensure we end up with a moment object\n  const moDate = mo._getMoment(date);\n\n  // never let reference date default to now if not provided\n  if (referenceDate) {\n    moReferenceDate = mo._getMoment(referenceDate);\n  }\n\n  // fail silently if the date is not worked out to be a moment\n  if (moDate) {\n    if (moReferenceDate) {\n      return moDate.calendar(moReferenceDate);\n    }\n    return moDate.calendar();\n  }\n\n  return null;\n});\n\nTemplate.registerHelper('moNow', () => mo.now.get());\n"]},"hash":"d04e0118c68d60f167f84af07e8955cd3a7156ed"}
