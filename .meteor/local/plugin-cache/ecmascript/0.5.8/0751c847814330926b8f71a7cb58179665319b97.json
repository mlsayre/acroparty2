{"metadata":{"usedHelpers":["classCallCheck"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/lbee:moment-helpers/common.js","filenameRelative":"/packages/lbee:moment-helpers/common.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/lbee:moment-helpers/common.js.map","sourceFileName":"/packages/lbee:moment-helpers/common.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"common"},"ignored":false,"code":"var _classCallCheck;module.import('babel-runtime/helpers/classCallCheck',{\"default\":function(v){_classCallCheck=v}});\n\nvar MomentHelperInit = function () {\n  // let self = this;\n\n  //\n\n  function MomentHelperInit(isClient) {\n    _classCallCheck(this, MomentHelperInit);\n\n    if (isClient) {\n      // create a new reactiveVar that holds the moment helper context of locale\n      this.currentLocale = new ReactiveVar();\n\n      // when creating the moment helper context, set the locale same as moment\n      this.currentLocale.set(moment.locale());\n\n      // reactive now\n      this.now = new ReactiveVar(moment());\n      var now = this.now;\n\n      Meteor.setInterval(function () {\n        now.set(moment());\n      }, 1000); // every second\n    }\n\n    // logging messages\n    this._msg = {\n      dateNotValidReturnNow: 'valid date not provided, sending new moment instead',\n      dateNotValidReturnNull: 'valid date not provided, sending null'\n    };\n\n    // initate the default options\n    this.options = {\n      // if a helper is called and no date given, create one as now\n      returnNowIfDateNotGiven: false,\n      // extra console logging\n      debug: false,\n      // initial library of format tokens\n      formatTokens: {\n        'default': 'LLL'\n        // defaults to locale date format: Month name, day of month, year, time\n      }\n    };\n  }\n\n  // configuration function, merges the defaults with the options provided\n\n\n  MomentHelperInit.prototype.configure = function configure(options) {\n    _.extend(this.options, options);\n  };\n\n  // expose a utility to set the locale, updating moment & reactive locale\n\n\n  MomentHelperInit.prototype.setLocale = function setLocale(locale) {\n    moment.locale(locale);\n    this.currentLocale.set(moment.locale()); // how does 'this' work?\n  };\n\n  // logging function\n\n\n  MomentHelperInit.prototype.log = function log(_log) {\n\n    // delete the currently stored log\n    // this was enabled to assit with logging\n    delete this.logged;\n\n    // if debugging is enabled, log it!\n    if (this.options.debug) {\n      this.logged = _log;\n      console.log(_log);\n    }\n  };\n\n  // used for moFormat, helps to get a format token eg. 'YYYY-MM-DD'\n\n\n  MomentHelperInit.prototype._getToken = function _getToken(token, aMoment) {\n    check(token, Match.Optional(String, null));\n    var tokenLibrary = _.defaults(this.options.formatTokens, {\n      // these tokens will always be available (unless overridden)\n      'dayOfWeek': 'dddd',\n      'dayOfMonth': 'D',\n      'month': 'M',\n      'year': 'YYYY',\n      'time': 'h:mm a'\n    });\n\n    // if no token provided, use the default from the token library\n    if (!token) {\n      token = 'default';\n    }\n\n    // see if the token is a reference to the token library, otherwise keep\n    token = tokenLibrary[token] || token;\n\n    // check if token is a function & process\n    if (_.isFunction(token)) {\n      token = token.call(aMoment);\n    }\n\n    // return the token\n    return token;\n  };\n\n  MomentHelperInit.prototype._getMoment = function _getMoment(obj) {\n\n    var result;\n    var date;\n\n    // goal is to get a moment object from what is provided\n    if (moment.isMoment(obj)) {\n      // if a moment is provided, return that moment, no questions asked\n      result = obj;\n    } else if (_.isDate(obj)) {\n      // if a date is provided, convert to moment and return\n      result = moment(obj);\n    } else if (_.isString(obj) && obj.length > 1) {\n      // attempt to get a date from the string\n\n      // if '|' is found, separate and use the RHS as the input format token\n      if (obj.indexOf('|') !== -1) {\n        date = moment(obj.substring(0, obj.indexOf('|')), // input string LHS of '|'\n        obj.substring(obj.indexOf('|') + 1) // input format, RHS after '|'\n        );\n      } else {\n          date = moment(new Date(obj));\n        }\n      if (date.isValid()) {\n        result = date;\n      }\n    }\n\n    // could not get a moment object, work out what to return if anything\n    if (!result) {\n      if (this.options.returnNowIfDateNotGiven) {\n        this.log(this._msg.dateNotValidReturnNow);\n        return moment();\n      } else {\n        this.log(this._msg.dateNotValidReturnNull);\n      }\n    }\n\n    return result;\n  };\n\n  return MomentHelperInit;\n}();\n\nmo = new MomentHelperInit(Meteor.isClient);","ast":null,"map":{"version":3,"sources":["/packages/lbee:moment-helpers/common.js"],"names":[],"mappings":"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","file":"/packages/lbee:moment-helpers/common.js.map","sourcesContent":["class MomentHelperInit {\n  // let self = this;\n\n  //\n  constructor ( isClient ) {\n\n    if ( isClient ) {\n      // create a new reactiveVar that holds the moment helper context of locale\n      this.currentLocale = new ReactiveVar();\n\n      // when creating the moment helper context, set the locale same as moment\n      this.currentLocale.set( moment.locale() );\n\n      // reactive now\n      this.now = new ReactiveVar( moment() );\n      var now = this.now;\n\n      Meteor.setInterval( function () {\n        now.set( moment() );\n      }, 1000 ); // every second\n    }\n\n    // logging messages\n    this._msg = {\n      dateNotValidReturnNow:\n        'valid date not provided, sending new moment instead',\n      dateNotValidReturnNull:\n        'valid date not provided, sending null'\n    };\n\n    // initate the default options\n    this.options = {\n      // if a helper is called and no date given, create one as now\n      returnNowIfDateNotGiven: false,\n      // extra console logging\n      debug: false,\n      // initial library of format tokens\n      formatTokens: {\n        'default': 'LLL'\n        // defaults to locale date format: Month name, day of month, year, time\n      }\n    };\n\n  }\n\n\n  // configuration function, merges the defaults with the options provided\n  configure ( options ) {\n    _.extend( this.options, options );\n  }\n\n  // expose a utility to set the locale, updating moment & reactive locale\n  setLocale ( locale ) {\n    moment.locale( locale );\n    this.currentLocale.set( moment.locale() );// how does 'this' work?\n  }\n\n  // logging function\n  log ( log ) {\n\n    // delete the currently stored log\n    // this was enabled to assit with logging\n    delete this.logged;\n\n    // if debugging is enabled, log it!\n    if ( this.options.debug ) {\n      this.logged = log;\n      console.log( log );\n    }\n  }\n\n  // used for moFormat, helps to get a format token eg. 'YYYY-MM-DD'\n  _getToken ( token, aMoment ) {\n    check( token, Match.Optional( String, null ) );\n    let tokenLibrary = _.defaults( this.options.formatTokens, {\n      // these tokens will always be available (unless overridden)\n      'dayOfWeek': 'dddd',\n      'dayOfMonth': 'D',\n      'month': 'M',\n      'year': 'YYYY',\n      'time': 'h:mm a'\n    });\n\n    // if no token provided, use the default from the token library\n    if ( !token ) {\n      token = 'default';\n    }\n\n    // see if the token is a reference to the token library, otherwise keep\n    token = tokenLibrary[token] || token;\n\n    // check if token is a function & process\n    if ( _.isFunction( token ) ) {\n      token = token.call( aMoment );\n    }\n\n    // return the token\n    return token;\n  }\n\n  _getMoment ( obj ) {\n    \n    var result;\n    var date;\n\n    // goal is to get a moment object from what is provided\n    if ( moment.isMoment( obj ) ) {\n      // if a moment is provided, return that moment, no questions asked\n      result = obj;\n    } else if ( _.isDate( obj ) ) {\n      // if a date is provided, convert to moment and return\n      result = moment( obj );\n    } else if ( _.isString( obj ) && obj.length > 1 ) {\n      // attempt to get a date from the string\n\n      // if '|' is found, separate and use the RHS as the input format token\n      if ( obj.indexOf( '|' ) !== -1 ) {\n        date = moment(\n          obj.substring( 0, obj.indexOf( '|' ) ), // input string LHS of '|'\n          obj.substring( obj.indexOf( '|' ) + 1 ) // input format, RHS after '|'\n        );\n      } else {\n        date = moment( new Date( obj ) );\n      }\n      if ( date.isValid() ) {\n        result = date;\n      }\n    }\n\n    // could not get a moment object, work out what to return if anything\n    if ( !result ) {\n      if ( this.options.returnNowIfDateNotGiven ) {\n        this.log( this._msg.dateNotValidReturnNow );\n        return moment();\n      } else {\n        this.log( this._msg.dateNotValidReturnNull );\n      }\n    }\n\n    return result;\n  }\n\n}\n\nmo = new MomentHelperInit( Meteor.isClient );\n"]},"hash":"0751c847814330926b8f71a7cb58179665319b97"}
