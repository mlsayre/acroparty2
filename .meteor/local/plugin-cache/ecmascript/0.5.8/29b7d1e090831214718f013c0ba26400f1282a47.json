{"metadata":{"usedHelpers":["classCallCheck"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/lbee:moment-helpers/client.js","filenameRelative":"/packages/lbee:moment-helpers/client.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/lbee:moment-helpers/client.js.map","sourceFileName":"/packages/lbee:moment-helpers/client.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"client"},"ignored":false,"code":"var _classCallCheck;module.import('babel-runtime/helpers/classCallCheck',{\"default\":function(v){_classCallCheck=v}});\n\nvar MomentHelper = function () {\n  function MomentHelper() {\n    _classCallCheck(this, MomentHelper);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    this.args = args;\n\n    // Calling this reactive property ensure the helper is updated\n    this.locale = mo.currentLocale.get();\n\n    // eg. {{moFormat date=myDate}} / {{moFormat myDate}} will do the same thing\n    this.keywords = args.pop();\n    this.dateA = args[0] || this.keywords.hash.d || this.keywords.hash.a;\n\n    // processes what was given to ensure we end up with a moment object\n    this.moDate = mo._getMoment(this.dateA);\n  }\n\n  MomentHelper.prototype.moFormat = function moFormat() {\n    if (this.moDate) {\n      this.formatToken = this.args[1] || this.keywords.hash.f;\n\n      return this.moDate.format(mo._getToken(this.formatToken, this.moDate));\n    }\n    // fail silently if the date is not worked out to be a moment\n    return null;\n  };\n\n  return MomentHelper;\n}();\n\nTemplate.registerHelper('moFormat', function () {\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return new (Function.prototype.bind.apply(MomentHelper, [null].concat(args)))().moFormat();\n});\n\nTemplate.registerHelper('moDiff', function moDiff() {\n  // Calling this reactive property ensure the helper is updated\n  var locale = mo.currentLocale.get(); // eslint-disable-line\n  var result = void 0;\n\n  // enables the arguments to be provided as args or vars\n\n  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  var kw = args.pop();\n  var dateA = mo._getMoment(args[0] || kw.hash.a);\n  var dateB = mo._getMoment(args[1] || kw.hash.b);\n  var units = args[2] || kw.hash.units || 'seconds';\n  var returnFloat = args[3] || kw.hash.returnFloat;\n\n  // if the returnFloat is truthy convert it to true, or falsy = false\n  if (returnFloat) {\n    returnFloat = true;\n  } else {\n    returnFloat = false;\n  }\n\n  // if the two dates are valid moment objects, send the result\n  if (dateA && dateB) {\n    result = dateA.diff(dateB, units, returnFloat);\n  }\n\n  // fail silently if the dates were not processed to a moment\n  return result;\n});\n\nTemplate.registerHelper('moFrom', function moFrom() {\n  // Calling this reactive property ensure the helper is updated\n  var locale = mo.currentLocale.get(); // eslint-disable-line\n  var result = void 0;\n\n  for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    args[_key4] = arguments[_key4];\n  }\n\n  var kw = args.pop();\n  var dateA = mo._getMoment(args[0] || kw.hash.a);\n  var dateB = mo._getMoment(args[1] || kw.hash.b);\n  var withoutSuffix = args[2] || kw.hash.withoutSuffix;\n\n  // if the withoutSuffix is truthy convert it to true, or falsy = false\n  if (withoutSuffix) {\n    withoutSuffix = true;\n  } else {\n    withoutSuffix = false;\n  }\n\n  // if the two dates are valid moment objects, send the result\n  if (dateA && dateB) {\n    result = dateA.from(dateB, withoutSuffix);\n  }\n\n  // fail silently if the dates were not processed to a moment\n  return result;\n});\n\nTemplate.registerHelper('moFromNow', function moFromNow() {\n  // Calling this reactive property ensure the helper is updated\n  var locale = mo.currentLocale.get(); // eslint-disable-line\n\n  // enables the arguments to be provided as args or vars\n\n  for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    args[_key5] = arguments[_key5];\n  }\n\n  var kw = args.pop();\n  var date = args[0] || kw.hash.d;\n  var withoutSuffix = args[1] || kw.hash.withoutSuffix;\n\n  // if the withoutSuffix is truthy convert it to true, or falsy = false\n  if (withoutSuffix) {\n    withoutSuffix = true;\n  } else {\n    withoutSuffix = false;\n  }\n\n  // work with what is given to get a moment object\n  var moDate = mo._getMoment(date);\n\n  // if we did end up with a valid object above, send the result\n  if (moDate) {\n    return moDate.fromNow(withoutSuffix);\n  }\n\n  // fail silently if the dates were not processed to a moment\n  return null;\n});\n\nTemplate.registerHelper('moCalendar', function moCalendar() {\n  // Calling this reactive property ensure the helper is updated\n  var locale = mo.currentLocale.get(); // eslint-disable-line\n\n  // enables the arguments to be provided as args or vars\n  // eg. {{moFormat date=myDate}} or {{moFormat myDate}} will do the same thing\n\n  for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    args[_key6] = arguments[_key6];\n  }\n\n  var kw = args.pop();\n  var date = args[0] || kw.hash.d;\n  var referenceDate = args[1] || kw.hash.r;\n  var moReferenceDate = void 0;\n\n  // processes what was given to ensure we end up with a moment object\n  var moDate = mo._getMoment(date);\n\n  // never let reference date default to now if not provided\n  if (referenceDate) {\n    moReferenceDate = mo._getMoment(referenceDate);\n  }\n\n  // fail silently if the date is not worked out to be a moment\n  if (moDate) {\n    if (moReferenceDate) {\n      return moDate.calendar(moReferenceDate);\n    }\n    return moDate.calendar();\n  }\n\n  return null;\n});\n\nTemplate.registerHelper('moNow', function () {\n  return mo.now.get();\n});","ast":null,"map":{"version":3,"sources":["/packages/lbee:moment-helpers/client.js"],"names":[],"mappings":"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","file":"/packages/lbee:moment-helpers/client.js.map","sourcesContent":["class MomentHelper {\n\n  constructor(...args) {\n    this.args = args;\n\n    // Calling this reactive property ensure the helper is updated\n    this.locale = mo.currentLocale.get();\n\n    // eg. {{moFormat date=myDate}} / {{moFormat myDate}} will do the same thing\n    this.keywords = args.pop();\n    this.dateA = args[0] || this.keywords.hash.d || this.keywords.hash.a;\n\n    // processes what was given to ensure we end up with a moment object\n    this.moDate = mo._getMoment(this.dateA);\n  }\n\n  moFormat() {\n    if (this.moDate) {\n      this.formatToken = this.args[1] || this.keywords.hash.f;\n\n      return this.moDate.format(\n        mo._getToken(this.formatToken, this.moDate)\n      );\n    }\n    // fail silently if the date is not worked out to be a moment\n    return null;\n  }\n\n}\n\nTemplate.registerHelper('moFormat', (...args) =>\n  new MomentHelper(...args).moFormat()\n);\n\nTemplate.registerHelper('moDiff', function moDiff(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n  let result;\n\n  // enables the arguments to be provided as args or vars\n  const kw = args.pop();\n  const dateA = mo._getMoment(args[0] || kw.hash.a);\n  const dateB = mo._getMoment(args[1] || kw.hash.b);\n  const units = args[2] || kw.hash.units || 'seconds';\n  let returnFloat = args[3] || kw.hash.returnFloat;\n\n  // if the returnFloat is truthy convert it to true, or falsy = false\n  if (returnFloat) {\n    returnFloat = true;\n  } else {\n    returnFloat = false;\n  }\n\n  // if the two dates are valid moment objects, send the result\n  if (dateA && dateB) {\n    result = dateA.diff(dateB, units, returnFloat);\n  }\n\n  // fail silently if the dates were not processed to a moment\n  return result;\n});\n\nTemplate.registerHelper('moFrom', function moFrom(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n  let result;\n\n  const kw = args.pop();\n  const dateA = mo._getMoment(args[0] || kw.hash.a);\n  const dateB = mo._getMoment(args[1] || kw.hash.b);\n  let withoutSuffix = args[2] || kw.hash.withoutSuffix;\n\n  // if the withoutSuffix is truthy convert it to true, or falsy = false\n  if (withoutSuffix) {\n    withoutSuffix = true;\n  } else {\n    withoutSuffix = false;\n  }\n\n  // if the two dates are valid moment objects, send the result\n  if (dateA && dateB) {\n    result = dateA.from(dateB, withoutSuffix);\n  }\n\n  // fail silently if the dates were not processed to a moment\n  return result;\n});\n\nTemplate.registerHelper('moFromNow', function moFromNow(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n\n  // enables the arguments to be provided as args or vars\n  const kw = args.pop();\n  const date = args[0] || kw.hash.d;\n  let withoutSuffix = args[1] || kw.hash.withoutSuffix;\n\n  // if the withoutSuffix is truthy convert it to true, or falsy = false\n  if (withoutSuffix) {\n    withoutSuffix = true;\n  } else {\n    withoutSuffix = false;\n  }\n\n  // work with what is given to get a moment object\n  const moDate = mo._getMoment(date);\n\n  // if we did end up with a valid object above, send the result\n  if (moDate) {\n    return moDate.fromNow(withoutSuffix);\n  }\n\n  // fail silently if the dates were not processed to a moment\n  return null;\n});\n\nTemplate.registerHelper('moCalendar', function moCalendar(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n\n  // enables the arguments to be provided as args or vars\n  // eg. {{moFormat date=myDate}} or {{moFormat myDate}} will do the same thing\n  const kw = args.pop();\n  const date = args[0] || kw.hash.d;\n  const referenceDate = args[1] || kw.hash.r;\n  let moReferenceDate;\n\n  // processes what was given to ensure we end up with a moment object\n  const moDate = mo._getMoment(date);\n\n  // never let reference date default to now if not provided\n  if (referenceDate) {\n    moReferenceDate = mo._getMoment(referenceDate);\n  }\n\n  // fail silently if the date is not worked out to be a moment\n  if (moDate) {\n    if (moReferenceDate) {\n      return moDate.calendar(moReferenceDate);\n    }\n    return moDate.calendar();\n  }\n\n  return null;\n});\n\nTemplate.registerHelper('moNow', () => mo.now.get());\n"]},"hash":"29b7d1e090831214718f013c0ba26400f1282a47"}
