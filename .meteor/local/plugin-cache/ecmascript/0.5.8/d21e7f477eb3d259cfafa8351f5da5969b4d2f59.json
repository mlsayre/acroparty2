{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/remcoder:chronos/chronos.js","filenameRelative":"/packages/remcoder:chronos/chronos.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/remcoder:chronos/chronos.js.map","sourceFileName":"/packages/remcoder:chronos/chronos.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"chronos"},"ignored":false,"code":"var moment = void 0;\n\n// if moment is not installed, fine. We don't require it as a hard dependency\ntry {\n  moment = require('moment');\n} catch (e) {}\n\nvar _timers = {};\n\nfunction Timer(interval) {\n  this.interval = interval || 1000;\n  this.time = new ReactiveVar(0);\n}\n\nTimer.prototype.start = function () {\n  if (this._timer) throw new Error('Trying to start Chronos.Timer but it is already running.');\n  this.time.set(new Date());\n\n  this._timer = setInterval(Meteor.bindEnvironment(function () {\n    //console.log('tick', this._timer);\n    this.time.set(new Date());\n  }.bind(this)), this.interval);\n};\n\nTimer.prototype.stop = function () {\n  //console.log('stopping timer');\n  clearInterval(this._timer);\n  this._timer = null;\n};\n\nfunction _update(interval) {\n  // get current reactive context\n  var comp = Tracker.currentComputation;\n  if (!comp) return; // no nothing when used outside a reactive context\n\n  // only create one timer per reactive context to prevent stacking of timers\n  var cid = comp && comp._id;\n  if (!_timers[cid]) {\n    (function () {\n      var timer = new Timer(interval);\n      _timers[cid] = timer;\n\n      // add destroy method that stops the timer and removes itself from the list\n      timer.destroy = function () {\n        timer.stop();\n        delete _timers[cid];\n      };\n\n      timer.start();\n    })();\n  }\n\n  // make sure to stop and delete the attached timer when the computation is stopped\n  comp.onInvalidate(function () {\n    //console.log('onInvalidated',comp);\n    if (comp.stopped && _timers[cid]) {\n      //console.log('computation stopped');\n      _timers[cid].destroy();\n    }\n  });\n\n  _timers[cid].time.dep.depend(comp); // make dependent on time\n\n  //console.log(_timers);\n  return _timers[cid];\n}\n\n// reactive version of moment()\n// please install moment separately\n// example usage: Chronos.moment(someTimestamp).format('ss');\nfunction _moment() /* arguments */{\n  if (!moment) throw new Error('moment not found. Please install it first');\n\n  _update();\n  return moment.apply(null, arguments);\n}\n\n// reactive version of new Date() get the current date/time\nfunction _date(interval) {\n  _update(interval);\n  return new Date();\n}\n\n// reactive version of Date.now(). get the current # of milliseconds since the start of the epoch\nfunction _now(interval) {\n  _update(interval);\n  return Date.now();\n}\n\n// export global\nChronos = {\n\n  // a simple reactive timer\n  // usage: var timer = new Timer();\n  // get current time: timer.time.get();\n  Timer: Timer,\n\n  // handy util func for making reactive contexts live updating in time\n  // usage: simply call Chronos.update() in your helper to make it execute\n  // every interval\n  update: _update,\n\n  // reactive version of new Date() get the current date/time\n  date: _date,\n\n  // reactive version of Date.now(). get the current # of milliseconds since the start of the epoch\n  now: _now,\n\n  // reactive version of moment()\n  // please install moment separately\n  // example usage: Chronos.moment(someTimestamp).format('ss');\n  moment: _moment,\n\n  // for debugging and testing\n  _timers: _timers,\n\n  // deprecated. but kept for backwards compatibility\n  liveUpdate: _update,\n  currentTime: _date,\n  liveMoment: _moment\n};","ast":null,"map":{"version":3,"sources":["/packages/remcoder:chronos/chronos.js"],"names":[],"mappings":"AAAA,IAAI,eAAJ;;;AAGA,IAAI;AACD,WAAS,QAAQ,QAAR,CAAT;AACF,CAFD,CAGA,OAAM,CAAN,EAAS,CACR;;AAED,IAAM,UAAU,EAAhB;;AAEA,SAAS,KAAT,CAAe,QAAf,EAAyB;AACvB,OAAK,QAAL,GAAgB,YAAY,IAA5B;AACA,OAAK,IAAL,GAAY,IAAI,WAAJ,CAAgB,CAAhB,CAAZ;AACD;;AAED,MAAM,SAAN,CAAgB,KAAhB,GAAwB,YAAW;AACjC,MAAI,KAAK,MAAT,EAAiB,MAAM,IAAI,KAAJ,CAAU,0DAAV,CAAN;AACjB,OAAK,IAAL,CAAU,GAAV,CAAc,IAAI,IAAJ,EAAd;;AAGA,OAAK,MAAL,GAAc,YAAY,OAAO,eAAP,CAAuB,YAAW;;AAE1D,SAAK,IAAL,CAAU,GAAV,CAAc,IAAI,IAAJ,EAAd;AAED,GAJgD,CAI/C,IAJ+C,CAI1C,IAJ0C,CAAvB,CAAZ,EAIC,KAAK,QAJN,CAAd;AAKD,CAVD;;AAYA,MAAM,SAAN,CAAgB,IAAhB,GAAuB,YAAW;;AAEhC,gBAAc,KAAK,MAAnB;AACA,OAAK,MAAL,GAAc,IAAd;AACD,CAJD;;AAMA,SAAS,OAAT,CAAiB,QAAjB,EAA2B;;AAEzB,MAAM,OAAO,QAAQ,kBAArB;AACA,MAAI,CAAC,IAAL,EACE,O;;;AAGF,MAAM,MAAO,QAAQ,KAAK,GAA1B;AACA,MAAI,CAAC,QAAQ,GAAR,CAAL,EAAmB;AAAA;AACjB,UAAM,QAAQ,IAAI,KAAJ,CAAU,QAAV,CAAd;AACA,cAAQ,GAAR,IAAe,KAAf;;;AAGA,YAAM,OAAN,GAAgB,YAAW;AACzB,cAAM,IAAN;AACA,eAAO,QAAQ,GAAR,CAAP;AACD,OAHD;;AAKA,YAAM,KAAN;AAViB;AAWlB;;;AAGD,OAAK,YAAL,CAAkB,YAAW;;AAE3B,QAAI,KAAK,OAAL,IAAgB,QAAQ,GAAR,CAApB,EAAkC;;AAEhC,cAAQ,GAAR,EAAa,OAAb;AACD;AACF,GAND;;AAQA,UAAQ,GAAR,EAAa,IAAb,CAAkB,GAAlB,CAAsB,MAAtB,CAA6B,IAA7B,E;;;AAGA,SAAO,QAAQ,GAAR,CAAP;AACD;;;;;AAKD,SAAS,OAAT,G,eAAkC;AAChC,MAAI,CAAC,MAAL,EAAa,MAAM,IAAI,KAAJ,CAAU,2CAAV,CAAN;;AAEb;AACA,SAAO,OAAO,KAAP,CAAa,IAAb,EAAmB,SAAnB,CAAP;AACD;;;AAGD,SAAS,KAAT,CAAe,QAAf,EAAyB;AACvB,UAAQ,QAAR;AACA,SAAO,IAAI,IAAJ,EAAP;AACD;;;AAGD,SAAS,IAAT,CAAc,QAAd,EAAwB;AACtB,UAAQ,QAAR;AACA,SAAO,KAAK,GAAL,EAAP;AACD;;;AAGD,UAAU;;;;;AAKR,cALQ;;;;;AAUR,UAAQ,OAVA;;;AAaR,QAAO,KAbC;;;AAgBR,OAAM,IAhBE;;;;;AAqBR,UAAS,OArBD;;;AAwBR,kBAxBQ;;;AA2BR,cAAa,OA3BL;AA4BR,eAAc,KA5BN;AA6BR,cAAa;AA7BL,CAAV","file":"/packages/remcoder:chronos/chronos.js.map","sourcesContent":["let moment;\n\n// if moment is not installed, fine. We don't require it as a hard dependency\ntry {\n   moment = require('moment');\n}\ncatch(e) {\n}\n\nconst _timers = {};\n\nfunction Timer(interval) {\n  this.interval = interval || 1000;\n  this.time = new ReactiveVar(0);  \n}\n\nTimer.prototype.start = function() {\n  if (this._timer) throw new Error('Trying to start Chronos.Timer but it is already running.');\n  this.time.set(new Date());\n\n\n  this._timer = setInterval(Meteor.bindEnvironment(function() {\n    //console.log('tick', this._timer);\n    this.time.set(new Date());\n\n  }.bind(this)), this.interval);\n};\n\nTimer.prototype.stop = function() {\n  //console.log('stopping timer');\n  clearInterval(this._timer);\n  this._timer = null;\n};\n\nfunction _update(interval) {\n  // get current reactive context\n  const comp = Tracker.currentComputation;\n  if (!comp)\n    return; // no nothing when used outside a reactive context\n\n  // only create one timer per reactive context to prevent stacking of timers\n  const cid =  comp && comp._id;\n  if (!_timers[cid]) {\n    const timer = new Timer(interval);\n    _timers[cid] = timer;\n\n    // add destroy method that stops the timer and removes itself from the list\n    timer.destroy = function() {\n      timer.stop();\n      delete _timers[cid];\n    };\n\n    timer.start();\n  }\n\n  // make sure to stop and delete the attached timer when the computation is stopped\n  comp.onInvalidate(function() {\n    //console.log('onInvalidated',comp);\n    if (comp.stopped && _timers[cid]) {\n      //console.log('computation stopped');\n      _timers[cid].destroy();\n    }\n  });\n\n  _timers[cid].time.dep.depend(comp); // make dependent on time\n\n  //console.log(_timers);\n  return _timers[cid];\n}\n\n// reactive version of moment()\n// please install moment separately\n// example usage: Chronos.moment(someTimestamp).format('ss');\nfunction _moment(/* arguments */) {\n  if (!moment) throw new Error('moment not found. Please install it first');\n  \n  _update();\n  return moment.apply(null, arguments);\n}\n\n// reactive version of new Date() get the current date/time\nfunction _date(interval) {\n  _update(interval);\n  return new Date();\n}\n\n// reactive version of Date.now(). get the current # of milliseconds since the start of the epoch\nfunction _now(interval) {\n  _update(interval);\n  return Date.now();\n}\n\n// export global\nChronos = {\n\n  // a simple reactive timer\n  // usage: var timer = new Timer();\n  // get current time: timer.time.get();\n  Timer,\n\n  // handy util func for making reactive contexts live updating in time\n  // usage: simply call Chronos.update() in your helper to make it execute\n  // every interval\n  update: _update,\n\n  // reactive version of new Date() get the current date/time\n  date : _date,\n\n  // reactive version of Date.now(). get the current # of milliseconds since the start of the epoch\n  now : _now,\n\n  // reactive version of moment()\n  // please install moment separately\n  // example usage: Chronos.moment(someTimestamp).format('ss');\n  moment : _moment,\n\n  // for debugging and testing\n  _timers,\n\n  // deprecated. but kept for backwards compatibility\n  liveUpdate : _update,\n  currentTime : _date,\n  liveMoment : _moment\n};"]},"hash":"d21e7f477eb3d259cfafa8351f5da5969b4d2f59"}
